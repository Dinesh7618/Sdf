// corrected_morphing_shape.frag
#ifdef GL_ES
#extension GL_OES_standard_derivatives : enable
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;

const float PI = 3.141592653589793;

// ------------------ helpers ------------------
mat2 rot(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }

float sdCircle(vec2 p, float r){ return length(p) - r; }

float sdBox(vec2 p, vec2 b) {
    vec2 q = abs(p) - b;
    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0);
}

float sdRoundBox(vec2 p, vec2 b, float r){
    vec2 q = abs(p) - b + vec2(r);
    return length(max(q, 0.0)) - r + min(max(q.x, q.y), 0.0);
}

// radial wavy circle: r' = r + amp * cos(n * theta + phase)
float sdWavyCircle(vec2 p, float r, float n, float amp, float phase){
    float theta = atan(p.y, p.x);
    float modR = r + amp * cos(n * theta + phase);
    return length(p) - modR;
}

// star/burst with sharpened spikes
float sdStar(vec2 p, float r, float spikes, float spikeAmp, float phase){
    float a = atan(p.y, p.x);
    float m = cos(spikes * a + phase);
    float spike = spikeAmp * sign(m) * pow(abs(m), 0.6);
    return length(p) - (r + spike);
}

// smooth union (blend)
float opSmoothUnion(float a, float b, float k){
    float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

// AA: uses derivatives when available, fallback otherwise
float AA(float sd){
#ifdef GL_OES_standard_derivatives
    float af = fwidth(sd);                 // accurate
#else
    // fallback using pixel size approx
    vec2 px = 1.0 / u_resolution;
    float af = length(px) * 1.5;
#endif
    // inside => sd < 0. We want 1 inside, 0 outside with smoothing width 'af'
    return clamp(smoothstep(0.0, af, -sd), 0.0, 1.0);
}

// ------------------ animated shape SDF ------------------
// blends a wavy "cookie" with a sharp burst
float sdAnimatedMorph(vec2 p, float time){
    // Keep aspect-correct coordinates inside: rotation + small global scale
    p *= rot(time * 0.25);
    p *= 1.0; // global scale if you want to tweak

    float baseR = 0.33;

    // time signals
    float t0 = 0.5 + 0.5 * sin(time * 1.2);  // 0..1 cycles slowly
    float phase = time * 1.6;

    float ampCookie = mix(0.035, 0.10, t0);
    float nCookie   = mix(6.0, 12.0, t0);

    float spikes    = mix(18.0, 10.0, 1.0 - t0);
    float spikeAmp  = mix(0.06, 0.16, 1.0 - t0);

    float wavy = sdWavyCircle(p, baseR, nCookie, ampCookie, phase);
    float star = sdStar(p, baseR, spikes, spikeAmp, phase * 0.6);

    // smooth-blend; k small => sharper junction
    float blend = 0.5 + 0.5 * sin(time * 0.9 + 0.3);
    // choose which to favor: when blend ~ 1 => wavy favored, when ~0 => star favored
    float d = opSmoothUnion(wavy, star, 0.05);

    // subtle vertical flatten (only slight) OPTIONAL: comment out if it clips
    // float flatten = p.y + 0.06; d = max(d, flatten); // <--- disabled to avoid "half" shapes

    return d;
}

// ------------------ main ------------------
void main(){
    // Centered, aspect-correct UV
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.x, u_resolution.y);

    // pick shape sdf
    float d = sdAnimatedMorph(uv, u_time);

    // anti-aliased alpha
    float a = AA(d);

    // colors (match your video)
    vec3 shapeColor = vec3(76.0/255.0, 51.0/255.0, 122.0/255.0);
    vec3 bg = vec3(244.0/255.0, 237.0/255.0, 249.0/255.0);

    // surface normal approx for faint rim (optional)
    vec2 e = vec2(0.001, 0.0);
    float ddx = sdAnimatedMorph(uv + e.xy, u_time) - sdAnimatedMorph(uv - e.xy, u_time);
    float ddy = sdAnimatedMorph(uv + e.yx, u_time) - sdAnimatedMorph(uv - e.yx, u_time);
    vec3 N = normalize(vec3(ddx, ddy, 0.0001));
    float rim = pow(1.0 - max(0.0, dot(N, vec3(0.0,1.0,0.0))), 3.0) * 0.03;

    vec3 col = mix(bg, shapeColor + rim * 0.25, a);

    // debug mode: uncomment to visualize signed distance (for debugging shapes)
//  col = vec3(0.5) + d * 2.0; // shows SDF gradient; comment out in final

    gl_FragColor = vec4(col, 1.0);
}
y}

// radial wavy circle: r' = r + amp * cos(n*theta + phase)
float sdWavyCircle(vec2 p, float r, float n, float amp, float phase){
    float theta = atan(p.y, p.x);
    float modR = r + amp * cos(n * theta + phase);
    return length(p) - modR;
}

// sharp star/burst: spikes via cos, sharpened by pow
float sdStar(vec2 p, float r, float spikes, float spikeAmp, float phase){
    float a = atan(p.y, p.x);
    float m = cos(spikes * a + phase);
    float spike = spikeAmp * sign(m) * pow(abs(m), 0.6);
    return length(p) - (r + spike);
}

// smooth union (blend factor k)
float opSmoothUnion(float a, float b, float k){
    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);
    return mix(b, a, h) - k*h*(1.0-h);
}

// anti-aliased step (using screen-space derivative)
float AA(float d){
    float fw = fwidth(d);
    return smoothstep(fw, -fw, d);
}

// ---------- Main animated shape SDF ----------
// This function blends between two SDFs over time to create the morphing effect.
float sdAnimatedMorph(vec2 p, float time){
    // rotate slowly
    float rotSpeed = 0.25;
    p *= rot(time * rotSpeed);

    // base radius
    float baseR = 0.33;

    // time-varying parameters
    float t1 = sin(time * 1.2) * 0.5 + 0.5;           // 0..1 oscillator
    float phase = time * 1.8;                         // rotates bumps
    float ampCookie = mix(0.04, 0.10, t1);            // cookie amplitude
    float nCookie = mix(6.0, 12.0, t1);               // cookie petals

    float spikes = mix(10.0, 20.0, 1.0 - t1);         // burst spikes
    float spikeAmp = mix(0.06, 0.16, 1.0 - t1);

    // two SDFs
    float wavy = sdWavyCircle(p, baseR, nCookie, ampCookie, phase);
    float star = sdStar(p, baseR, spikes, spikeAmp, phase*0.6);

    // smooth blend between them based on another slow oscillator
    float blend = 0.5 + 0.5 * sin(time * 0.9 + 0.3);
    float d = opSmoothUnion(wavy, star, 0.06 * (1.0 - blend) + 0.01);

    // small inner indent to match the slightly flattened look in the reference
    // (subtract a small flattened circle on bottom to get "pill-like" bottom)
    float flatten = p.y + 0.05; // positive above, negative below
    d = max(d, flatten);

    return d;
}

// ---------- Fragment main ----------
void main(){
    // normalized coordinates centered at (0,0)
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;

    // get SDF
    float d = sdAnimatedMorph(uv, u_time);

    // alpha with anti-aliasing
    float a = AA(d);

    // color setup (exact matches from the video)
    vec3 shapeColor = vec3(76.0/255.0, 51.0/255.0, 122.0/255.0); // main purple
    vec3 accent = vec3(133.0/255.0,108.0/255.0,180.0/255.0);    // accent (unused by default)
    vec3 bg = vec3(244.0/255.0,237.0/255.0,249.0/255.0);        // pale background

    // lighting-like subtle rim: compute approximate normal from SDF and add very small rim
    vec2 eps = vec2(0.001, 0.0);
    float dx = sdAnimatedMorph(uv + eps.xy, u_time) - sdAnimatedMorph(uv - eps.xy, u_time);
    float dy = sdAnimatedMorph(uv + eps.yx, u_time) - sdAnimatedMorph(uv - eps.yx, u_time);
    vec3 N = normalize(vec3(dx, dy, 0.0001));
    float rim = pow(1.0 - max(0.0, dot(N, vec3(0.0,1.0,0.0))), 3.0) * 0.06;

    // final color: mix background and shape
    vec3 col = mix(bg, shapeColor + rim * accent, a);

    gl_FragColor = vec4(col, 1.0);
}
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;

// ---------- Helpers ----------
const float PI = 3.14159265358979323846;

mat2 rot(float a){ float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }

float sdCircle(vec2 p, float r){ return length(p) - r; }
float sdBox(vec2 p, vec2 b){
    vec2 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);
}
float sdRoundBox(vec2 p, vec2 b, float rad){
    vec2 q = abs(p) - b + vec2(rad);
    return length(max(q, 0.0)) - rad + min(max(q.x, q.y), 0.0);
}

// radial wavy circle: r' = r + amp * cos(n*theta + phase)
float sdWavyCircle(vec2 p, float r, float n, float amp, float phase){
    float theta = atan(p.y, p.x);
    float modR = r + amp * cos(n * theta + phase);
    return length(p) - modR;
}

// sharp star/burst: spikes via cos, sharpened by pow
float sdStar(vec2 p, float r, float spikes, float spikeAmp, float phase){
    float a = atan(p.y, p.x);
    float m = cos(spikes * a + phase);
    float spike = spikeAmp * sign(m) * pow(abs(m), 0.6);
    return length(p) - (r + spike);
}

// smooth union (blend factor k)
float opSmoothUnion(float a, float b, float k){
    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);
    return mix(b, a, h) - k*h*(1.0-h);
}

// anti-aliased step (using screen-space derivative)
float AA(float d){
    float fw = fwidth(d);
    return smoothstep(fw, -fw, d);
}

// ---------- Main animated shape SDF ----------
// This function blends between two SDFs over time to create the morphing effect.
float sdAnimatedMorph(vec2 p, float time){
    // rotate slowly
    float rotSpeed = 0.25;
    p *= rot(time * rotSpeed);

    // base radius
    float baseR = 0.33;

    // time-varying parameters
    float t1 = sin(time * 1.2) * 0.5 + 0.5;           // 0..1 oscillator
    float phase = time * 1.8;                         // rotates bumps
    float ampCookie = mix(0.04, 0.10, t1);            // cookie amplitude
    float nCookie = mix(6.0, 12.0, t1);               // cookie petals

    float spikes = mix(10.0, 20.0, 1.0 - t1);         // burst spikes
    float spikeAmp = mix(0.06, 0.16, 1.0 - t1);

    // two SDFs
    float wavy = sdWavyCircle(p, baseR, nCookie, ampCookie, phase);
    float star = sdStar(p, baseR, spikes, spikeAmp, phase*0.6);

    // smooth blend between them based on another slow oscillator
    float blend = 0.5 + 0.5 * sin(time * 0.9 + 0.3);
    float d = opSmoothUnion(wavy, star, 0.06 * (1.0 - blend) + 0.01);

    // small inner indent to match the slightly flattened look in the reference
    // (subtract a small flattened circle on bottom to get "pill-like" bottom)
    float flatten = p.y + 0.05; // positive above, negative below
    d = max(d, flatten);

    return d;
}

// ---------- Fragment main ----------
void main(){
    // normalized coordinates centered at (0,0)
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;

    // get SDF
    float d = sdAnimatedMorph(uv, u_time);

    // alpha with anti-aliasing
    float a = AA(d);

    // color setup (exact matches from the video)
    vec3 shapeColor = vec3(76.0/255.0, 51.0/255.0, 122.0/255.0); // main purple
    vec3 accent = vec3(133.0/255.0,108.0/255.0,180.0/255.0);    // accent (unused by default)
    vec3 bg = vec3(244.0/255.0,237.0/255.0,249.0/255.0);        // pale background

    // lighting-like subtle rim: compute approximate normal from SDF and add very small rim
    vec2 eps = vec2(0.001, 0.0);
    float dx = sdAnimatedMorph(uv + eps.xy, u_time) - sdAnimatedMorph(uv - eps.xy, u_time);
    float dy = sdAnimatedMorph(uv + eps.yx, u_time) - sdAnimatedMorph(uv - eps.yx, u_time);
    vec3 N = normalize(vec3(dx, dy, 0.0001));
    float rim = pow(1.0 - max(0.0, dot(N, vec3(0.0,1.0,0.0))), 3.0) * 0.06;

    // final color: mix background and shape
    vec3 col = mix(bg, shapeColor + rim * accent, a);

    gl_FragColor = vec4(col, 1.0);
}
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;

// ---------- Helpers ----------
const float PI = 3.14159265358979323846;

mat2 rot(float a){ float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }

float sdCircle(vec2 p, float r){ return length(p) - r; }
float sdBox(vec2 p, vec2 b){
    vec2 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);
}
float sdRoundBox(vec2 p, vec2 b, float rad){
    vec2 q = abs(p) - b + vec2(rad);
    return length(max(q, 0.0)) - rad + min(max(q.x, q.y), 0.0);
}

// radial wavy circle: r' = r + amp * cos(n*theta + phase)
float sdWavyCircle(vec2 p, float r, float n, float amp, float phase){
    float theta = atan(p.y, p.x);
    float modR = r + amp * cos(n * theta + phase);
    return length(p) - modR;
}

// sharp star/burst: spikes via cos, sharpened by pow
float sdStar(vec2 p, float r, float spikes, float spikeAmp, float phase){
    float a = atan(p.y, p.x);
    float m = cos(spikes * a + phase);
    float spike = spikeAmp * sign(m) * pow(abs(m), 0.6);
    return length(p) - (r + spike);
}

// smooth union (blend factor k)
float opSmoothUnion(float a, float b, float k){
    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);
    return mix(b, a, h) - k*h*(1.0-h);
}

// anti-aliased step (using screen-space derivative)
float AA(float d){
    float fw = fwidth(d);
    return smoothstep(fw, -fw, d);
}

// ---------- Main animated shape SDF ----------
// This function blends between two SDFs over time to create the morphing effect.
float sdAnimatedMorph(vec2 p, float time){
    // rotate slowly
    float rotSpeed = 0.25;
    p *= rot(time * rotSpeed);

    // base radius
    float baseR = 0.33;

    // time-varying parameters
    float t1 = sin(time * 1.2) * 0.5 + 0.5;           // 0..1 oscillator
    float phase = time * 1.8;                         // rotates bumps
    float ampCookie = mix(0.04, 0.10, t1);            // cookie amplitude
    float nCookie = mix(6.0, 12.0, t1);               // cookie petals

    float spikes = mix(10.0, 20.0, 1.0 - t1);         // burst spikes
    float spikeAmp = mix(0.06, 0.16, 1.0 - t1);

    // two SDFs
    float wavy = sdWavyCircle(p, baseR, nCookie, ampCookie, phase);
    float star = sdStar(p, baseR, spikes, spikeAmp, phase*0.6);

    // smooth blend between them based on another slow oscillator
    float blend = 0.5 + 0.5 * sin(time * 0.9 + 0.3);
    float d = opSmoothUnion(wavy, star, 0.06 * (1.0 - blend) + 0.01);

    // small inner indent to match the slightly flattened look in the reference
    // (subtract a small flattened circle on bottom to get "pill-like" bottom)
    float flatten = p.y + 0.05; // positive above, negative below
    d = max(d, flatten);

    return d;
}

// ---------- Fragment main ----------
void main(){
    // normalized coordinates centered at (0,0)
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;

    // get SDF
    float d = sdAnimatedMorph(uv, u_time);

    // alpha with anti-aliasing
    float a = AA(d);

    // color setup (exact matches from the video)
    vec3 shapeColor = vec3(76.0/255.0, 51.0/255.0, 122.0/255.0); // main purple
    vec3 accent = vec3(133.0/255.0,108.0/255.0,180.0/255.0);    // accent (unused by default)
    vec3 bg = vec3(244.0/255.0,237.0/255.0,249.0/255.0);        // pale background

    // lighting-like subtle rim: compute approximate normal from SDF and add very small rim
    vec2 eps = vec2(0.001, 0.0);
    float dx = sdAnimatedMorph(uv + eps.xy, u_time) - sdAnimatedMorph(uv - eps.xy, u_time);
    float dy = sdAnimatedMorph(uv + eps.yx, u_time) - sdAnimatedMorph(uv - eps.yx, u_time);
    vec3 N = normalize(vec3(dx, dy, 0.0001));
    float rim = pow(1.0 - max(0.0, dot(N, vec3(0.0,1.0,0.0))), 3.0) * 0.06;

    // final color: mix background and shape
    vec3 col = mix(bg, shapeColor + rim * accent, a);

    gl_FragColor = vec4(col, 1.0);
}
// corrected_morphing_shape.frag
#ifdef GL_ES
#extension GL_OES_standard_derivatives : enable
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;

const float PI = 3.141592653589793;

// ------------------ helpers ------------------
mat2 rot(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }

float sdCircle(vec2 p, float r){ return length(p) - r; }

float sdBox(vec2 p, vec2 b) {
    vec2 q = abs(p) - b;
    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0);
}

float sdRoundBox(vec2 p, vec2 b, float r){
    vec2 q = abs(p) - b + vec2(r);
    return length(max(q, 0.0)) - r + min(max(q.x, q.y), 0.0);
}

// radial wavy circle: r' = r + amp * cos(n * theta + phase)
float sdWavyCircle(vec2 p, float r, float n, float amp, float phase){
    float theta = atan(p.y, p.x);
    float modR = r + amp * cos(n * theta + phase);
    return length(p) - modR;
}

// star/burst with sharpened spikes
float sdStar(vec2 p, float r, float spikes, float spikeAmp, float phase){
    float a = atan(p.y, p.x);
    float m = cos(spikes * a + phase);
    float spike = spikeAmp * sign(m) * pow(abs(m), 0.6);
    return length(p) - (r + spike);
}

// smooth union (blend)
float opSmoothUnion(float a, float b, float k){
    float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

// AA: uses derivatives when available, fallback otherwise
float AA(float sd){
#ifdef GL_OES_standard_derivatives
    float af = fwidth(sd);                 // accurate
#else
    // fallback using pixel size approx
    vec2 px = 1.0 / u_resolution;
    float af = length(px) * 1.5;
#endif
    // inside => sd < 0. We want 1 inside, 0 outside with smoothing width 'af'
    return clamp(smoothstep(0.0, af, -sd), 0.0, 1.0);
}

// ------------------ animated shape SDF ------------------
// blends a wavy "cookie" with a sharp burst
float sdAnimatedMorph(vec2 p, float time){
    // Keep aspect-correct coordinates inside: rotation + small global scale
    p *= rot(time * 0.25);
    p *= 1.0; // global scale if you want to tweak

    float baseR = 0.33;

    // time signals
    float t0 = 0.5 + 0.5 * sin(time * 1.2);  // 0..1 cycles slowly
    float phase = time * 1.6;

    float ampCookie = mix(0.035, 0.10, t0);
    float nCookie   = mix(6.0, 12.0, t0);

    float spikes    = mix(18.0, 10.0, 1.0 - t0);
    float spikeAmp  = mix(0.06, 0.16, 1.0 - t0);

    float wavy = sdWavyCircle(p, baseR, nCookie, ampCookie, phase);
    float star = sdStar(p, baseR, spikes, spikeAmp, phase * 0.6);

    // smooth-blend; k small => sharper junction
    float blend = 0.5 + 0.5 * sin(time * 0.9 + 0.3);
    // choose which to favor: when blend ~ 1 => wavy favored, when ~0 => star favored
    float d = opSmoothUnion(wavy, star, 0.05);

    // subtle vertical flatten (only slight) OPTIONAL: comment out if it clips
    // float flatten = p.y + 0.06; d = max(d, flatten); // <--- disabled to avoid "half" shapes

    return d;
}

// ------------------ main ------------------
void main(){
    // Centered, aspect-correct UV
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.x, u_resolution.y);

    // pick shape sdf
    float d = sdAnimatedMorph(uv, u_time);

    // anti-aliased alpha
    float a = AA(d);

    // colors (match your video)
    vec3 shapeColor = vec3(76.0/255.0, 51.0/255.0, 122.0/255.0);
    vec3 bg = vec3(244.0/255.0, 237.0/255.0, 249.0/255.0);

    // surface normal approx for faint rim (optional)
    vec2 e = vec2(0.001, 0.0);
    float ddx = sdAnimatedMorph(uv + e.xy, u_time) - sdAnimatedMorph(uv - e.xy, u_time);
    float ddy = sdAnimatedMorph(uv + e.yx, u_time) - sdAnimatedMorph(uv - e.yx, u_time);
    vec3 N = normalize(vec3(ddx, ddy, 0.0001));
    float rim = pow(1.0 - max(0.0, dot(N, vec3(0.0,1.0,0.0))), 3.0) * 0.03;

    vec3 col = mix(bg, shapeColor + rim * 0.25, a);

    // debug mode: uncomment to visualize signed distance (for debugging shapes)
//  col = vec3(0.5) + d * 2.0; // shows SDF gradient; comment out in final

    gl_FragColor = vec4(col, 1.0);
}
